{
  "language": "Solidity",
  "sources": {
    "@freemarket/core/contracts/IWorkflowRunner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './model/AssetAmount.sol';\nimport './model/Workflow.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\n/// @notice An interface defining the entry point to the engine for executing workflows.\ninterface IWorkflowRunner {\n  /// @notice Initiate the execution of a workflow.\n  /// @param workflow The workflow to execute.\n  function executeWorkflow(Workflow calldata workflow) external payable;\n\n  /// @notice Continue a workflow that started on a different chain.\n  /// @notice This is not callable by 3rd parties, only approved bridge integrations call this method.\n  function continueWorkflow(\n    address userAddress,\n    uint256 nonce,\n    Workflow memory workflow,\n    AssetAmount[] memory startingAssets\n  ) external payable;\n}\n"
    },
    "@freemarket/core/contracts/IWorkflowStep.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './model/Asset.sol';\nimport './model/AssetAmount.sol';\nimport './model/WorkflowStepResult.sol';\n\n/// @title The interface between WorkflowRunner and each Step implementation.abi\n/// @author Marty Saxton\n/// @notice All steps must implement this interface.\ninterface IWorkflowStep {\n  /// @notice called by WorkflowRunner to execute a workflow step.\n  /// @param assetAmounts AssetAmounts to be used by the step\n  /// @param argData Step specific arguments in ABI encoding\n  /// @param userAddress the address of the user\n  /// @return the outcome of the step invocation\n  function execute(\n    AssetAmount[] calldata assetAmounts,\n    bytes calldata argData,\n    address userAddress\n  ) external payable returns (WorkflowStepResult memory);\n}\n"
    },
    "@freemarket/core/contracts/IWorkflowStepAfterAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/// @title The interface between WorkflowRunner and each Step implementation when the step needs\n/// to do something after the steps in the workflow are done executing.\n/// @author Marty Saxton\n/// @notice This interface is optional.\ninterface IWorkflowStepAfterAll {\n  /// @notice called by WorkflowRunner to execute some logic after the workflow ends.\n  /// @param argData Step specific arguments in ABI encoding\n  /// @param userAddress The address of the user executing the workflow\n  function afterAll(bytes calldata argData, address userAddress) external payable;\n}\n"
    },
    "@freemarket/core/contracts/IWorkflowStepBeforeAll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/// @title The interface between WorkflowRunner and each Step implementation when the step needs\n/// to do something before the steps in the workflow execute.\n/// @author Marty Saxton\n/// @notice This interface is optional.\ninterface IWorkflowStepBeforeAll {\n  /// @notice called by WorkflowRunner to execute some logic before the workflow starts.\n  /// @param argData Step specific arguments in ABI encoding\n  /// @param userAddress The address of the user executing the workflow\n  function beforeAll(bytes calldata argData, address userAddress) external payable;\n}\n"
    },
    "@freemarket/core/contracts/LibPercent.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nlibrary LibPercent {\n    /// Percents have 3 decimals of precision, so:\n    /// 100% is represented as 100000 (100.000%)\n    /// 1% is represented as 1000 (1.000%)\n    /// 1 basis point (1/100th of a percent or 0.010% ) is 10\n    /// the smallest possible percentage is 1/10th of a basis point, or 1 'decibip'\n    /// @param value the value to take a percentage of\n    /// @param percent the percentage in decibips\n    function percentageOf(uint256 value, uint256 percent) internal pure returns (uint256) {\n        require(0 <= percent && percent <= 100000, \"percent must be between 0 and 100000\");\n        uint256 x = value * percent;\n        return x / 100000;\n    }\n}\n"
    },
    "@freemarket/core/contracts/model/Asset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./AssetType.sol\";\n\nstruct Asset {\n    AssetType assetType;\n    address assetAddress; // 0x0 for ETH, the ERC20 address.  If it's an account balance, this could represent the token of the account\n}\n"
    },
    "@freemarket/core/contracts/model/AssetAmount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './Asset.sol';\n\nstruct AssetAmount {\n  Asset asset;\n  uint256 amount;\n}\n"
    },
    "@freemarket/core/contracts/model/AssetType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum AssetType {\n    Native,\n    ERC20,\n    ERC721\n}\n"
    },
    "@freemarket/core/contracts/model/Workflow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './WorkflowStep.sol';\n\nstruct BeforeAfter {\n  uint16 stepTypeId;\n  address stepAddress;\n  bytes argData;\n}\n\n// The main workflow data structure.\nstruct Workflow {\n  // The address of the WorkflowRunner contract, allowing the caller to specify an older version of the runner.\n  // If this is the zero address, the most current version of the runner will be used.\n  // If a non-zero address is specified, it must be a whitelisted address of a previous WorkflowRunner contract.\n  address workflowRunnerAddress;\n  // The nodes in the directed graph of steps.\n  // The start step is defined to be at index 0.\n  // The 'edges' in the graph are defined within each WorkflowStep,\n  // but can be overriden in the return value of a step.\n  WorkflowStep[] steps;\n  BeforeAfter[] beforeAll;\n  BeforeAfter[] afterAll;\n}\n"
    },
    "@freemarket/core/contracts/model/WorkflowStep.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './WorkflowStepInputAsset.sol';\n\n// Parameters for a workflow step\nstruct WorkflowStep {\n  // The logical identifer of the step (e.g., 10 represents WrapEtherStep).\n  uint16 stepTypeId;\n  // The contract address of a specific version of the action.\n  // Individual step contracts may be upgraded over time, and this allows\n  // workflows 'freeze' the version of contract for this step\n  // A value of address(0) means use the latest and greatest version  of\n  // this step based only on stepTypeId.\n  address stepAddress;\n  // The input assets to this step.\n  WorkflowStepInputAsset[] inputAssets;\n  // Additional step-specific parameters for this step, typically serialized in standard abi encoding.\n  bytes argData;\n  // The index of the next step in the directed graph of steps. (see the Workflow.steps array)\n  int16 nextStepIndex;\n}\n"
    },
    "@freemarket/core/contracts/model/WorkflowStepInputAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './Asset.sol';\n\n// an input asset to a WorkflowStep\nstruct WorkflowStepInputAsset {\n  // if true, the source of the asset is the caller of the workflow, otherwise it is the output of some previous step\n  bool sourceIsCaller;\n  // if true 'amount' is treated as a percent, with 4 decimals of precision (1000000 represents 100%)\n  bool amountIsPercent;\n  // the input asset\n  Asset asset;\n  // the amount of the input asset\n  uint256 amount;\n}\n"
    },
    "@freemarket/core/contracts/model/WorkflowStepResult.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './AssetAmount.sol';\n\n// The return value from the execution of a step.\nstruct WorkflowStepResult {\n  // The amounts of each input asset that resulted from the step execution.\n  AssetAmount[] inputAssetAmounts;\n  // The amounts of each output asset that resulted from the step execution.\n  AssetAmount[] outputAssetAmounts;\n  // The amounts of each output asset that resulted from the step execution.\n  AssetAmount[] outputAssetAmountsToCaller;\n  // The index of the next step in a workflow.\n  // This value allows the step to override the default nextStepIndex\n  // statically defined\n  // -1 means terminate the workflow\n  // -2 means do not override the statically defined nextStepIndex in WorkflowStep\n  int16 nextStepIndex;\n  // the fee to be withheald out of the output assets (in absolute currency units)\n  // -1 means use the default fee\n  int24 fee;\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToUintMap storage map,\n        uint256 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToUintMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/AssetComparisons.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport '@freemarket/core/contracts/model/WorkflowStep.sol';\nimport './LibAssetBalances.sol';\n\nimport './Comparison.sol';\n\nusing LibAssetBalances for LibAssetBalances.AssetBalances;\n\n\nstruct AssetComparisonParams {\n  Asset asset;\n  Comparison comparison;\n  uint256 amount;\n  int16 ifYes;\n}\n\nenum AssetComparisonType {\n  Balance,\n  Credit,\n  Debit\n}\n\nlibrary AssetComparison {\n  function getNextStepIndex(\n    WorkflowStep memory currentStep,\n    LibAssetBalances.AssetBalances memory assetBalances,\n    AssetComparisonType assetComparisonType\n  ) internal view returns (int16) {\n    AssetComparisonParams memory args = abi.decode(currentStep.argData, (AssetComparisonParams));\n    Comparison comparision = args.comparison;\n    LibAssetBalances.AssetEntry memory assetEntry = LibAssetBalances.getAssetEntry(assetBalances, args.asset);\n\n    uint256 amount;\n    if (assetComparisonType == AssetComparisonType.Balance) {\n      amount = assetEntry.balance;\n    } else  if (assetComparisonType == AssetComparisonType.Credit) {\n      amount = assetEntry.previousCredit;\n    } else {\n      amount = assetEntry.previousDebit;\n    }\n\n    uint256 argsAmount = args.amount;\n    bool result;\n    assembly {\n      switch comparision\n      case 0 {\n        result := eq(amount, argsAmount)\n      }\n      case 1 {\n        result := not(eq(amount, argsAmount))\n      }\n      case 2 {\n        result := lt(amount, argsAmount)\n      }\n      case 3 {\n        result := or(eq(amount, argsAmount), lt(amount, argsAmount))\n      }\n      case 4 {\n        result := gt(amount, argsAmount)\n      }\n      case 5 {\n        result := or(eq(amount, argsAmount), gt(amount, argsAmount))\n      }\n    }\n    if (result) {\n\n\n      return args.ifYes;\n    }\n\n\n    return currentStep.nextStepIndex;\n  }\n}\n"
    },
    "contracts/ChainBranch.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport '@freemarket/core/contracts/model/WorkflowStep.sol';\n\n\nstruct ChainBranchParams {\n  uint256 chainId;\n  int16 ifYes;\n}\n\nlibrary ChainBranch {\n  function getNextStepIndex(WorkflowStep memory currentStep) internal view returns (int16) {\n    ChainBranchParams memory args = abi.decode(currentStep.argData, (ChainBranchParams));\n    if (args.chainId == block.chainid) {\n\n\n      return args.ifYes;\n    }\n\n\n    return currentStep.nextStepIndex;\n  }\n}\n"
    },
    "contracts/Comparison.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum Comparison {\n  Equal,\n  NotEqual,\n  LessThan,\n  LessThanOrEqual,\n  GreaterThan,\n  GreaterThanOrEqual\n}\n"
    },
    "contracts/ConfigManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './EternalStorage.sol';\nimport './StepInfo.sol';\nimport './LibConfigReader.sol';\nimport './FreeMarketBase.sol';\nimport './FrontDoor.sol';\n\nstruct StepFee {\n  uint16 stepTypeId;\n  bool feeIsPercent;\n  uint256 fee;\n}\n\ncontract ConfigManager is FreeMarketBase {\n  address public immutable frontDoorAddress;\n\n  event StepFeeUpdated(uint16 stepTypeId, uint256 oldFee, bool oldFeeIsPercent, uint256 newFee, bool newFeeIsPercent);\n  event DefaultFeeUpdated(uint256 oldFee, bool oldFeeIsPercent, uint256 newFee, bool newFeeIsPercent);\n\n  constructor(\n    address payable _frontDoorAddress\n  )\n    FreeMarketBase(\n      msg.sender, // owner\n      FrontDoor(_frontDoorAddress).eternalStorageAddress(), // eternal storage address\n      address(0), // upstream (this doesn't have one)\n      false // isUserProxy\n    )\n  {\n    frontDoorAddress = _frontDoorAddress;\n  }\n\n  function getStepAddress(uint16 stepTypeId) external view returns (address) {\n    return LibConfigReader.getStepAddressInternal(eternalStorageAddress, stepTypeId);\n  }\n\n  function getStepCount() external view returns (uint256) {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    return eternalStorage.lengthEnumerableMapUintToAddress(LibConfigReader.latestStepAddresses);\n  }\n\n  function getStepInfoAt(uint256 index) public view returns (StepInfo memory) {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    (uint256 stepTypeId, address stepAddress) = eternalStorage.atEnumerableMapUintToAddress(LibConfigReader.latestStepAddresses, index);\n\n    bytes32 whitelistKey = LibConfigReader.getStepWhitelistKey(uint16(stepTypeId));\n    uint256 whitelistCount = eternalStorage.lengthEnumerableMapAddressToUint(whitelistKey);\n    address[] memory whitelist = new address[](whitelistCount);\n    for (uint256 i = 0; i < whitelistCount; ++i) {\n      (address whitelistedAddress, ) = eternalStorage.atEnumerableMapAddressToUint(whitelistKey, i);\n      whitelist[i] = whitelistedAddress;\n    }\n\n    bytes32 blacklistKey = LibConfigReader.getStepBlacklistKey(uint16(stepTypeId));\n    uint256 blacklistCount = eternalStorage.lengthEnumerableMapAddressToUint(blacklistKey);\n    address[] memory blacklist = new address[](blacklistCount);\n    for (uint256 i = 0; i < blacklistCount; ++i) {\n      (address blacklistedAddress, ) = eternalStorage.atEnumerableMapAddressToUint(blacklistKey, i);\n      blacklist[i] = blacklistedAddress;\n    }\n\n    (uint256 fee, bool feeIsPercent) = LibConfigReader.getStepFee(eternalStorageAddress, uint16(stepTypeId));\n    return StepInfo(uint16(stepTypeId), feeIsPercent, fee, stepAddress, whitelist, blacklist);\n  }\n\n  event StepAddressSetEvent(uint16 stepTypeId, address stepAddress);\n\n  function setStepAddress(uint16 stepTypeId, address stepAddress) external onlyOwner {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    eternalStorage.setEnumerableMapUintToAddress(LibConfigReader.latestStepAddresses, stepTypeId, stepAddress);\n    // using the white list map like a set, we only care about the keys\n    // this sets it as the current step for the stepTypeId\n    eternalStorage.setEnumerableMapAddressToUint(LibConfigReader.getStepWhitelistKey(stepTypeId), stepAddress, 0);\n    // this adds it to the list of all valid steps\n    eternalStorage.setEnumerableMapAddressToUint(LibConfigReader.allStepAddresses, stepAddress, 0);\n    // remove it from the black list just in case it was there\n    eternalStorage.removeEnumerableMapAddressToUint(LibConfigReader.getStepBlacklistKey(stepTypeId), stepAddress);\n    emit StepAddressSetEvent(stepTypeId, stepAddress);\n  }\n\n  function removeStepAddress(uint16 stepTypeId, address stepAddress) external onlyOwner {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    address latest = eternalStorage.getEnumerableMapUintToAddress(LibConfigReader.latestStepAddresses, stepTypeId);\n    require(stepAddress != latest, 'cannot remove latest step address');\n    eternalStorage.setEnumerableMapAddressToUint(LibConfigReader.getStepBlacklistKey(stepTypeId), stepAddress, 0);\n    eternalStorage.removeEnumerableMapAddressToUint(LibConfigReader.getStepWhitelistKey(stepTypeId), stepAddress);\n    eternalStorage.removeEnumerableMapAddressToUint(LibConfigReader.allStepAddresses, stepAddress);\n    emit StepAddressSetEvent(stepTypeId, stepAddress);\n  }\n\n  function addRunnerAddress(address runnerAddress) external onlyOwner {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    // using the map like a set, we only care about the keys\n    eternalStorage.setEnumerableMapAddressToUint(LibConfigReader.runnerAddresses, runnerAddress, 0);\n  }\n\n  function removeRunnerAddress(address runnerAddress) external onlyOwner {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    eternalStorage.removeEnumerableMapAddressToUint(LibConfigReader.runnerAddresses, runnerAddress);\n  }\n\n  function getRunnerAddresses() external view returns (address[] memory) {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    uint256 count = eternalStorage.lengthEnumerableMapAddressToUint(LibConfigReader.runnerAddresses);\n    address[] memory runners = new address[](count);\n    for (uint256 i = 0; i < count; ++i) {\n      (address runnerAddress, ) = eternalStorage.atEnumerableMapAddressToUint(LibConfigReader.runnerAddresses, i);\n      runners[i] = runnerAddress;\n    }\n    return runners;\n  }\n\n  function setDefaultFee(uint256 fee, bool feeIsPercent) external onlyOwner {\n    require(feeIsPercent || fee & LibConfigReader.FEE_MASK == 0, 'absolute fee out of bounds');\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    uint256 encodedFee = LibConfigReader.encodeFee(fee, feeIsPercent);\n    bytes32 feeKey = LibConfigReader.getDefaultFeeKey();\n    uint256 existingEncodedFee = eternalStorage.getUint(LibConfigReader.getDefaultFeeKey());\n    if (encodedFee != existingEncodedFee) {\n      eternalStorage.setUint(feeKey, encodedFee);\n      (uint256 existingFee, bool existingFeeIsPercent) = LibConfigReader.decodeFee(encodedFee);\n      emit DefaultFeeUpdated(existingFee, existingFeeIsPercent, fee, feeIsPercent);\n    }\n  }\n\n  function setStepFees(StepFee[] calldata stepFeeUpdates) external onlyOwner {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    for (uint256 i = 0; i < stepFeeUpdates.length; ++i) {\n      // if its an absolute value, it cannot have the top bit set\n      require(stepFeeUpdates[i].feeIsPercent || stepFeeUpdates[i].fee & LibConfigReader.FEE_MASK == 0, 'absolute fee out of bounds');\n      bytes32 feeKey = LibConfigReader.getStepFeeKey(stepFeeUpdates[i].stepTypeId);\n      // read the exising fee data and see if it's changing\n      uint256 existingFeeEncoded = eternalStorage.getUint(feeKey);\n      uint256 feeEncoded = LibConfigReader.encodeFee(stepFeeUpdates[i].fee, stepFeeUpdates[i].feeIsPercent);\n      if (feeEncoded != existingFeeEncoded) {\n        (uint256 existingFee, bool existingFeeIsPercent) = LibConfigReader.decodeFee(existingFeeEncoded);\n        emit StepFeeUpdated(\n          stepFeeUpdates[i].stepTypeId,\n          existingFee,\n          existingFeeIsPercent,\n          stepFeeUpdates[i].fee,\n          stepFeeUpdates[i].feeIsPercent\n        );\n        eternalStorage.setUint(feeKey, feeEncoded);\n      }\n    }\n  }\n\n  function getStepFee(uint16 stepTypeId) external view returns (uint256, bool) {\n    return LibConfigReader.getStepFee(eternalStorageAddress, stepTypeId);\n  }\n\n  function getDefaultFee() external view returns (uint256, bool) {\n    return LibConfigReader.getDefaultFee(eternalStorageAddress);\n  }\n\n  function getSubscribers() external view returns (address[] memory) {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    uint256 count = eternalStorage.lengthEnumerableMapAddressToUint(LibConfigReader.subscribers);\n    address[] memory subscribers = new address[](count);\n    for (uint256 i = 0; i < count; ++i) {\n      (address subscriber, ) = eternalStorage.atEnumerableMapAddressToUint(LibConfigReader.subscribers, i);\n      subscribers[i] = subscriber;\n    }\n    return subscribers;\n  }\n\n  // not very scalable, but OK for now\n  // would be better to add/remove subscribers one at a time\n  function updateSubscribers(address[] calldata newSubscribers) external {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    // delete all existing subscribers\n    while (true) {\n      uint256 count = eternalStorage.lengthEnumerableMapAddressToUint(LibConfigReader.subscribers);\n      if (count == 0) {\n        break;\n      }\n      (address subscriber, ) = eternalStorage.atEnumerableMapAddressToUint(LibConfigReader.subscribers, count - 1);\n      eternalStorage.removeEnumerableMapAddressToUint(LibConfigReader.subscribers, subscriber);\n    }\n\n    // add current subscribers back in\n    for (uint256 i = 0; i < newSubscribers.length; ++i) {\n      eternalStorage.setEnumerableMapAddressToUint(LibConfigReader.subscribers, newSubscribers[i], 0);\n    }\n  }\n\n  function getAllStepAddesses() external view returns (address[] memory) {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    uint256 count = eternalStorage.lengthEnumerableMapAddressToUint(LibConfigReader.allStepAddresses);\n    address[] memory subscribers = new address[](count);\n    for (uint256 i = 0; i < count; ++i) {\n      (address subscriber, ) = eternalStorage.atEnumerableMapAddressToUint(LibConfigReader.allStepAddresses, i);\n      subscribers[i] = subscriber;\n    }\n    return subscribers;\n  }\n}\n"
    },
    "contracts/EternalStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport '@openzeppelin/contracts/utils/structs/EnumerableMap.sol';\n\nimport './Ownable.sol';\n\ncontract EternalStorage is Ownable {\n  address internal writer;\n\n  modifier onlyWriter() {\n    require(msg.sender == writer);\n    _;\n  }\n\n  constructor(address owner, address initialWriter) Ownable(owner) {\n    writer = initialWriter;\n  }\n\n  event StorageWriterChanged(address oldWriter, address newWriter);\n\n  function getWriter() public view returns (address) {\n    return writer;\n  }\n\n  function setWriter(address newWriter) public onlyOwner {\n    emit StorageWriterChanged(writer, newWriter);\n    writer = newWriter;\n  }\n\n  mapping(bytes32 => uint256) uIntStorage;\n  mapping(bytes32 => string) stringStorage;\n  mapping(bytes32 => address) addressStorage;\n  mapping(bytes32 => bytes) bytesStorage;\n  mapping(bytes32 => bool) boolStorage;\n  mapping(bytes32 => int256) intStorage;\n\n  using EnumerableMap for EnumerableMap.UintToAddressMap;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n  using EnumerableMap for EnumerableMap.Bytes32ToBytes32Map;\n  using EnumerableMap for EnumerableMap.UintToUintMap;\n  using EnumerableMap for EnumerableMap.Bytes32ToUintMap;\n  mapping(bytes32 => EnumerableMap.UintToAddressMap) enumerableMapUintToAddressMapStorage;\n  mapping(bytes32 => EnumerableMap.AddressToUintMap) enumerableMapAddressToUintMapStorage;\n  mapping(bytes32 => EnumerableMap.Bytes32ToBytes32Map) enumerableMapBytes32ToBytes32MapStorage;\n  mapping(bytes32 => EnumerableMap.UintToUintMap) enumerableMapUintToUintMapStorage;\n  mapping(bytes32 => EnumerableMap.Bytes32ToUintMap) enumerableMapBytes32ToUintMapStorage;\n\n  // *** Getter Methods ***\n  function getUint(bytes32 _key) external view returns (uint256) {\n    return uIntStorage[_key];\n  }\n\n  function getString(bytes32 _key) external view returns (string memory) {\n    return stringStorage[_key];\n  }\n\n  function getAddress(bytes32 _key) external view returns (address) {\n    return addressStorage[_key];\n  }\n\n  function getBytes(bytes32 _key) external view returns (bytes memory) {\n    return bytesStorage[_key];\n  }\n\n  function getBool(bytes32 _key) external view returns (bool) {\n    return boolStorage[_key];\n  }\n\n  function getInt(bytes32 _key) external view returns (int256) {\n    return intStorage[_key];\n  }\n\n  // *** Setter Methods ***\n  function setUint(bytes32 _key, uint256 _value) external onlyWriter {\n    uIntStorage[_key] = _value;\n  }\n\n  function setString(bytes32 _key, string memory _value) external onlyWriter {\n    stringStorage[_key] = _value;\n  }\n\n  function setAddress(bytes32 _key, address _value) external {\n    addressStorage[_key] = _value;\n  }\n\n  function setBytes(bytes32 _key, bytes memory _value) external onlyWriter {\n    bytesStorage[_key] = _value;\n  }\n\n  function setBool(bytes32 _key, bool _value) external onlyWriter {\n    boolStorage[_key] = _value;\n  }\n\n  function setInt(bytes32 _key, int256 _value) external onlyWriter {\n    intStorage[_key] = _value;\n  }\n\n  // *** Delete Methods ***\n  function deleteUint(bytes32 _key) external onlyWriter {\n    delete uIntStorage[_key];\n  }\n\n  function deleteString(bytes32 _key) external onlyWriter {\n    delete stringStorage[_key];\n  }\n\n  function deleteAddress(bytes32 _key) external onlyWriter {\n    delete addressStorage[_key];\n  }\n\n  function deleteBytes(bytes32 _key) external onlyWriter {\n    delete bytesStorage[_key];\n  }\n\n  function deleteBool(bytes32 _key) external onlyWriter {\n    delete boolStorage[_key];\n  }\n\n  function deleteInt(bytes32 _key) external onlyWriter {\n    delete intStorage[_key];\n  }\n\n  // enumerable get\n\n  function getEnumerableMapUintToAddress(bytes32 _key1, uint256 _key2) external view returns (address) {\n    return enumerableMapUintToAddressMapStorage[_key1].get(_key2);\n  }\n\n  function getEnumerableMapAddressToUint(bytes32 _key1, address _key2) external view returns (uint256) {\n    return enumerableMapAddressToUintMapStorage[_key1].get(_key2);\n  }\n\n  function getEnumerableMapBytes32ToBytes32(bytes32 _key1, bytes32 _key2) external view returns (bytes32) {\n    return enumerableMapBytes32ToBytes32MapStorage[_key1].get(_key2);\n  }\n\n  function getEnumerableMapUintToUint(bytes32 _key1, uint256 _key2) external view returns (uint256) {\n    return enumerableMapUintToUintMapStorage[_key1].get(_key2);\n  }\n\n  function getEnumerableMapBytes32ToUint(bytes32 _key1, bytes32 _key2) external view returns (uint256) {\n    return enumerableMapBytes32ToUintMapStorage[_key1].get(_key2);\n  }\n\n  // enumerable tryGet\n\n  function tryGetEnumerableMapUintToAddress(bytes32 _key1, uint256 _key2) external view returns (bool, address) {\n    return enumerableMapUintToAddressMapStorage[_key1].tryGet(_key2);\n  }\n\n  function tryGetEnumerableMapAddressToUint(bytes32 _key1, address _key2) external view returns (bool, uint256) {\n    return enumerableMapAddressToUintMapStorage[_key1].tryGet(_key2);\n  }\n\n  function tryGetEnumerableMapBytes32ToBytes32(bytes32 _key1, bytes32 _key2) external view returns (bool, bytes32) {\n    return enumerableMapBytes32ToBytes32MapStorage[_key1].tryGet(_key2);\n  }\n\n  function tryGetEnumerableMapUintToUint(bytes32 _key1, uint256 _key2) external view returns (bool, uint256) {\n    return enumerableMapUintToUintMapStorage[_key1].tryGet(_key2);\n  }\n\n  function tryGetEnumerableMapBytes32ToUint(bytes32 _key1, bytes32 _key2) external view returns (bool, uint256) {\n    return enumerableMapBytes32ToUintMapStorage[_key1].tryGet(_key2);\n  }\n\n  // enumerable set\n\n  function setEnumerableMapUintToAddress(bytes32 _key1, uint256 _key2, address _value) external onlyWriter returns (bool) {\n    return enumerableMapUintToAddressMapStorage[_key1].set(_key2, _value);\n  }\n\n  function setEnumerableMapAddressToUint(bytes32 _key1, address _key2, uint256 _value) external onlyWriter returns (bool) {\n    return enumerableMapAddressToUintMapStorage[_key1].set(_key2, _value);\n  }\n\n  function setEnumerableMapBytes32ToBytes32(bytes32 _key1, bytes32 _key2, bytes32 _value) external onlyWriter returns (bool) {\n    return enumerableMapBytes32ToBytes32MapStorage[_key1].set(_key2, _value);\n  }\n\n  function setEnumerableMapUintToUint(bytes32 _key1, uint256 _key2, uint256 _value) external onlyWriter returns (bool) {\n    return enumerableMapUintToUintMapStorage[_key1].set(_key2, _value);\n  }\n\n  function setEnumerableMapBytes32ToUint(bytes32 _key1, bytes32 _key2, uint256 _value) external onlyWriter returns (bool) {\n    return enumerableMapBytes32ToUintMapStorage[_key1].set(_key2, _value);\n  }\n\n  // enumerable remove\n\n  function removeEnumerableMapUintToAddress(bytes32 _key1, uint256 _key2) external onlyWriter {\n    enumerableMapUintToAddressMapStorage[_key1].remove(_key2);\n  }\n\n  function removeEnumerableMapAddressToUint(bytes32 _key1, address _key2) external onlyWriter {\n    enumerableMapAddressToUintMapStorage[_key1].remove(_key2);\n  }\n\n  function removeEnumerableMapBytes32ToBytes32(bytes32 _key1, bytes32 _key2) external onlyWriter {\n    enumerableMapBytes32ToBytes32MapStorage[_key1].remove(_key2);\n  }\n\n  function removeEnumerableMapUintToUint(bytes32 _key1, uint256 _key2) external onlyWriter {\n    enumerableMapUintToUintMapStorage[_key1].remove(_key2);\n  }\n\n  function removeEnumerableMapBytes32ToUint(bytes32 _key1, bytes32 _key2) external onlyWriter {\n    enumerableMapBytes32ToUintMapStorage[_key1].remove(_key2);\n  }\n\n  // enumerable contains\n\n  function containsEnumerableMapUintToAddress(bytes32 _key1, uint256 _key2) external view returns (bool) {\n    return enumerableMapUintToAddressMapStorage[_key1].contains(_key2);\n  }\n\n  function containsEnumerableMapAddressToUint(bytes32 _key1, address _key2) external view returns (bool) {\n    return enumerableMapAddressToUintMapStorage[_key1].contains(_key2);\n  }\n\n  function containsEnumerableMapBytes32ToBytes32(bytes32 _key1, bytes32 _key2) external view returns (bool) {\n    return enumerableMapBytes32ToBytes32MapStorage[_key1].contains(_key2);\n  }\n\n  function containsEnumerableMapUintToUint(bytes32 _key1, uint256 _key2) external view returns (bool) {\n    return enumerableMapUintToUintMapStorage[_key1].contains(_key2);\n  }\n\n  function containsEnumerableMapBytes32ToUint(bytes32 _key1, bytes32 _key2) external view returns (bool) {\n    return enumerableMapBytes32ToUintMapStorage[_key1].contains(_key2);\n  }\n\n  // enumerable length\n\n  function lengthEnumerableMapUintToAddress(bytes32 _key1) external view returns (uint256) {\n    return enumerableMapUintToAddressMapStorage[_key1].length();\n  }\n\n  function lengthEnumerableMapAddressToUint(bytes32 _key1) external view returns (uint256) {\n    return enumerableMapAddressToUintMapStorage[_key1].length();\n  }\n\n  function lengthEnumerableMapBytes32ToBytes32(bytes32 _key1) external view returns (uint256) {\n    return enumerableMapBytes32ToBytes32MapStorage[_key1].length();\n  }\n\n  function lengthEnumerableMapUintToUint(bytes32 _key1) external view returns (uint256) {\n    return enumerableMapUintToUintMapStorage[_key1].length();\n  }\n\n  function lengthEnumerableMapBytes32ToUint(bytes32 _key1) external view returns (uint256) {\n    return enumerableMapBytes32ToUintMapStorage[_key1].length();\n  }\n\n  // enumerable at\n\n  function atEnumerableMapUintToAddress(bytes32 _key1, uint256 _index) external view returns (uint256, address) {\n    return enumerableMapUintToAddressMapStorage[_key1].at(_index);\n  }\n\n  function atEnumerableMapAddressToUint(bytes32 _key1, uint256 _index) external view returns (address, uint256) {\n    return enumerableMapAddressToUintMapStorage[_key1].at(_index);\n  }\n\n  function atEnumerableMapBytes32ToBytes32(bytes32 _key1, uint256 _index) external view returns (bytes32, bytes32) {\n    return enumerableMapBytes32ToBytes32MapStorage[_key1].at(_index);\n  }\n\n  function atEnumerableMapUintToUint(bytes32 _key1, uint256 _index) external view returns (uint256, uint256) {\n    return enumerableMapUintToUintMapStorage[_key1].at(_index);\n  }\n\n  function atEnumerableMapBytes32ToUint(bytes32 _key1, uint256 _index) external view returns (bytes32, uint256) {\n    return enumerableMapBytes32ToUintMapStorage[_key1].at(_index);\n  }\n}\n"
    },
    "contracts/FreeMarketBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport './Ownable.sol';\n\ncontract FreeMarketBase is Ownable {\n  // TODO create getters\n  address public eternalStorageAddress;\n  address public upstreamAddress;\n  bool public isUserProxy;\n\n  constructor(\n    address owner,\n    address eternalStorage,\n    address upstream,\n    bool userProxy\n  ) Ownable(owner) {\n    eternalStorageAddress = eternalStorage;\n    upstreamAddress = upstream;\n    isUserProxy = userProxy;\n  }\n}\n"
    },
    "contracts/FrontDoor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport './EternalStorage.sol';\nimport './Proxy.sol';\nimport './LibStorageWriter.sol';\n\ncontract FrontDoor is Proxy {\n  constructor() Proxy(msg.sender, address(new EternalStorage(msg.sender, address(0))), address(0x0), false) {\n    bytes32 key = keccak256(abi.encodePacked('frontDoor'));\n    StorageWriter.setAddress(eternalStorageAddress, key, address(this));\n  }\n\n  event UpstreamChanged(address oldUpstream, address newUpstream);\n  event UpstreamRemoved(address oldUpstream);\n\n  function setUpstream(address newUpstream) public onlyOwner {\n    address oldUpstream = upstreamAddress;\n    upstreamAddress = newUpstream;\n    emit UpstreamChanged(oldUpstream, newUpstream);\n  }\n}\n"
    },
    "contracts/IHasUpstream.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ninterface IHasUpstream {\n  function getUpstream() external view returns (address);\n}\n"
    },
    "contracts/LibAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@freemarket/core/contracts/model/Asset.sol\";\n\nlibrary LibAsset {\n    function encodeAsset(Asset memory asset) internal pure returns (uint256) {\n        return encodeAsset(asset.assetType, asset.assetAddress);\n    }\n\n    function encodeAsset(AssetType assetType, address assetAddress) internal pure returns (uint256) {\n        uint160 a1 = uint160(assetAddress);\n        uint256 a2 = uint256(a1);\n        uint256 a3 = a2 << 16;\n        uint256 t1 = uint256(assetType);\n        uint256 a4 = a3 | t1;\n        return a4;\n        // return (uint256(uint160(assetAddress)) << 16) & uint256(assetType);\n    }\n\n    function decodeAsset(uint256 assetInt) internal pure returns (Asset memory) {\n        AssetType assetType = AssetType(uint16(assetInt));\n        address addr = address(uint160(assetInt >> 16));\n        return Asset(assetType, addr);\n    }\n}\n"
    },
    "contracts/LibAssetBalances.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '@freemarket/core/contracts/model/AssetAmount.sol';\nimport './LibAsset.sol';\n\nusing Strings for uint256;\n\nlibrary LibAssetBalances {\n  uint8 constant MAX_ENTRIES = 10;\n\n  struct AssetEntry {\n    uint256 asset;\n    uint256 balance;\n    uint256 previousCredit;\n    uint256 previousDebit;\n  }\n\n  struct AssetBalances {\n    AssetEntry[MAX_ENTRIES] entries;\n    uint8 end;\n  }\n\n  function getAssetBalance(AssetBalances memory entrySet, Asset memory asset) internal pure returns (uint256) {\n    return getAssetEntry(entrySet, asset).balance;\n  }\n\n  function getPreviousCredit(AssetBalances memory entrySet, Asset memory asset) internal pure returns (uint256) {\n    return getAssetEntry(entrySet, asset).previousCredit;\n  }\n\n  function getPreviousDebit(AssetBalances memory entrySet, Asset memory asset) internal pure returns (uint256) {\n    return getAssetEntry(entrySet, asset).previousDebit;\n  }\n\n  function getAssetEntry(AssetBalances memory entrySet, Asset memory asset) internal pure returns (AssetEntry memory) {\n    AssetEntry[MAX_ENTRIES] memory entries = entrySet.entries;\n    uint256 assetAsInt = LibAsset.encodeAsset(asset);\n    for (uint16 i = 0; i < entrySet.end; ++i) {\n      if (entries[i].asset == assetAsInt) {\n        return entries[i];\n      }\n    }\n    return AssetEntry(0, 0, 0, 0);\n  }\n\n  function credit(AssetBalances memory entrySet, uint256 assetAsInt, uint256 amount) internal pure {\n    if (amount > 0) {\n      uint256 index = getAssetIndex(entrySet, assetAsInt);\n      (bool success, uint256 newBalance) = SafeMath.tryAdd(entrySet.entries[index].balance, amount);\n      if (!success) {\n        revertArithmetic('credit', assetAsInt, entrySet.entries[index].balance, amount);\n      }\n      // updateBalance(entrySet, index, newBalance);\n      entrySet.entries[index].balance = newBalance;\n      entrySet.entries[index].previousCredit = amount;\n    }\n  }\n\n  function debit(AssetBalances memory entrySet, uint256 assetAsInt, uint256 amount) internal pure {\n    if (amount > 0) {\n      uint256 index = getAssetIndex(entrySet, assetAsInt);\n      (bool success, uint256 newBalance) = SafeMath.trySub(entrySet.entries[index].balance, amount);\n      if (!success) {\n        revertArithmetic('debit', assetAsInt, entrySet.entries[index].balance, amount);\n      }\n      // updateBalance(entrySet, index, newBalance);\n      entrySet.entries[index].balance = newBalance;\n      entrySet.entries[index].previousDebit = amount;\n    }\n  }\n\n  function credit(AssetBalances memory entrySet, Asset memory asset, uint256 amount) internal pure {\n    credit(entrySet, LibAsset.encodeAsset(asset), amount);\n  }\n\n  function debit(AssetBalances memory entrySet, Asset memory asset, uint256 amount) internal pure {\n    debit(entrySet, LibAsset.encodeAsset(asset), amount);\n  }\n\n  function revertArithmetic(string memory op, uint256 assetAsInt, uint256 a, uint256 b) internal pure {\n    Asset memory asset = LibAsset.decodeAsset(assetAsInt);\n    revert(\n      string.concat(\n        op,\n        ' assetType=',\n        uint256(asset.assetType).toString(),\n        ' assetAddress=',\n        uint256(uint160(asset.assetAddress)).toHexString(),\n        ' values ',\n        a.toString(),\n        ', ',\n        b.toString()\n      )\n    );\n  }\n\n  function updateBalance(AssetBalances memory entrySet, uint256 index, uint256 newBalance) internal pure returns (uint256) {\n    if (newBalance == 0) {\n      removeAt(entrySet, index);\n    } else {\n      entrySet.entries[index].balance = newBalance;\n    }\n    return newBalance;\n  }\n\n  function removeAt(AssetBalances memory entrySet, uint256 index) internal pure {\n    entrySet.entries[index] = entrySet.entries[entrySet.end - 1];\n    --entrySet.end;\n  }\n\n  function getAssetIndex(AssetBalances memory entrySet, Asset memory asset) internal pure returns (uint256) {\n    uint256 assetAsInt = LibAsset.encodeAsset(asset);\n    return getAssetIndex(entrySet, assetAsInt);\n  }\n\n  function getAssetIndex(AssetBalances memory entrySet, uint256 assetAsInt) internal pure returns (uint256) {\n    for (uint256 i = 0; i < entrySet.end; ++i) {\n      if (entrySet.entries[i].asset == assetAsInt) {\n        return i;\n      }\n    }\n    require(entrySet.end < MAX_ENTRIES, 'too many token balances');\n    entrySet.entries[entrySet.end] = AssetEntry(assetAsInt, 0, 0, 0);\n    return entrySet.end++;\n  }\n\n  function getAssetCount(AssetBalances memory entrySet) internal pure returns (uint8) {\n    return entrySet.end;\n  }\n\n  function getAssetAt(AssetBalances memory entrySet, uint8 index) internal pure returns (AssetAmount memory) {\n    require(index < entrySet.end, 'index out of bounds while accessing asset balances');\n    Asset memory a = LibAsset.decodeAsset(entrySet.entries[index].asset);\n    return AssetAmount(a, entrySet.entries[index].balance);\n  }\n}\n"
    },
    "contracts/LibConfigReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './EternalStorage.sol';\n\nlibrary LibConfigReader {\n  string constant STEP_FEES_KEY = 'stepFees';\n  string constant DEFAULT_FEE_KEY = 'defaultFees';\n  uint256 constant FEE_MASK = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n  // latestStepAddresses maps stepTypeId to latest and greatest version of that step\n  bytes32 constant latestStepAddresses = 0xc94d198e6194ea38dbd900920351d7f8e6c6d85b1d3b803fb93c54be008e11fd; // keccak256('latestActionAddresses')\n  bytes32 constant runnerAddresses = 0x32b7d36eef9191cec628a9b46ddda74b702cf693ad48a065f3f9e5fcc4ea08f5; // keccak256('runnerAddresses')\n  bytes32 constant allStepAddresses = 0x18fa4b105101c66136345367eab77cd274c0766ec0596b7e8aadd79e99139555; // keccak256('allStepAddresses')\n  bytes32 public constant subscribers = keccak256('subscribers');\n\n  function getStepAddressInternal(address eternalStorageAddress, uint16 stepTypeId) internal view returns (address) {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    return eternalStorage.getEnumerableMapUintToAddress(latestStepAddresses, stepTypeId);\n  }\n\n  function getStepWhitelistKey(uint16 stepTypeId) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked('stepWhiteList', stepTypeId));\n  }\n\n  function getStepBlacklistKey(uint16 stepTypeId) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked('stepBlackList', stepTypeId));\n  }\n\n  function isStepAddressWhitelisted(address eternalStorageAddress, uint16 stepTypeId, address stepAddress) internal view returns (bool) {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    return eternalStorage.containsEnumerableMapAddressToUint(getStepWhitelistKey(stepTypeId), stepAddress);\n  }\n\n  function isStepAddressWhitelisted(address eternalStorageAddress, address stepAddress) internal view returns (bool) {\n    EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n    return eternalStorage.containsEnumerableMapAddressToUint(allStepAddresses, stepAddress);\n  }\n\n  function getStepFeeKey(uint16 stepTypeId) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(STEP_FEES_KEY, stepTypeId));\n  }\n\n  function getDefaultFeeKey() internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(DEFAULT_FEE_KEY));\n  }\n\n  function encodeFee(uint256 _fee, bool isPercent) internal pure returns (uint256) {\n    uint256 fee = _fee;\n    if (isPercent) {\n      fee |= FEE_MASK;\n    }\n    return fee;\n  }\n\n  function decodeFee(uint256 feeEncoded) internal pure returns (uint256, bool) {\n    bool isPercent = (feeEncoded & FEE_MASK) > 0;\n    uint256 fee = feeEncoded & ~FEE_MASK;\n    return (fee, isPercent);\n  }\n\n  function getDefaultFee(address eternalStorageAddress) internal view returns (uint256, bool) {\n    uint256 encodedFee = EternalStorage(eternalStorageAddress).getUint(getDefaultFeeKey());\n    return decodeFee(encodedFee);\n  }\n\n  function getStepFee(address eternalStorageAddress, uint16 stepTypeId) internal view returns (uint256, bool) {\n    uint256 encodedFee = EternalStorage(eternalStorageAddress).getUint(getStepFeeKey(stepTypeId));\n    return decodeFee(encodedFee);\n  }\n\n  function isSubscriber(address eternalStorageAddress, address callerAddress) internal view returns (bool) {\n    return EternalStorage(eternalStorageAddress).containsEnumerableMapAddressToUint(subscribers, callerAddress);\n  }\n}\n"
    },
    "contracts/LibStorageWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nlibrary StorageWriter {\n    // *** Setter Methods ***\n    function setUint(address storageAddr, bytes32 key, uint256 value) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setUint(bytes32,uint256)\", key, value));\n        require(success, string(returnData));\n    }\n\n    function setString(address storageAddr, bytes32 key, string memory value) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setString(bytes32,string memory)\", key, value));\n        require(success, string(returnData));\n    }\n\n    function setAddress(address storageAddr, bytes32 key, address value) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setAddress(bytes32,address)\", key, value));\n        require(success, string(returnData));\n    }\n\n    function setBytes(address storageAddr, bytes32 key, bytes memory value) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setBytes(bytes32,bytes memory)\", key, value));\n        require(success, string(returnData));\n    }\n\n    function setBool(address storageAddr, bytes32 key, bool value) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setBool(bytes32,bool)\", key, value));\n        require(success, string(returnData));\n    }\n\n    function setInt(address storageAddr, bytes32 key, int256 value) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setInt(bytes32,int256)\", key, value));\n        require(success, string(returnData));\n    }\n\n    // *** Delete Methods ***\n    function deleteUint(address storageAddr, bytes32 key) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"deleteUint(bytes32,string memory)\", key));\n        require(success, string(returnData));\n    }\n\n    function deleteString(address storageAddr, bytes32 key) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setString(bytes32,string memory)\", key));\n        require(success, string(returnData));\n    }\n\n    function deleteAddress(address storageAddr, bytes32 key) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setString(bytes32,string memory)\", key));\n        require(success, string(returnData));\n    }\n\n    function deleteBytes(address storageAddr, bytes32 key) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setString(bytes32,string memory)\", key));\n        require(success, string(returnData));\n    }\n\n    function deleteBool(address storageAddr, bytes32 key) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setString(bytes32,string memory)\", key));\n        require(success, string(returnData));\n    }\n\n    function deleteInt(address storageAddr, bytes32 key) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setString(bytes32,string memory)\", key));\n        require(success, string(returnData));\n    }\n\n    function setStepAddress(address storageAddr, uint16 stepTypeId, address stepAddress) internal {\n        (bool success, bytes memory returnData) =\n            storageAddr.delegatecall(abi.encodeWithSignature(\"setStepAddress(uint16,address)\", stepTypeId, stepAddress));\n        require(success, string(returnData));\n    }\n}\n"
    },
    "contracts/Lock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n//\n\ncontract Lock {\n    uint public unlockTime;\n    address payable public owner;\n\n    event Withdrawal(uint amount, uint when);\n\n    constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp < _unlockTime,\n            \"Unlock time should be in the future\"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n    }\n\n    function withdraw() public {\n        // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal\n\n\n        require(block.timestamp >= unlockTime, \"You can't withdraw yet\");\n        require(msg.sender == owner, \"You aren't the owner\");\n\n        emit Withdrawal(address(this).balance, block.timestamp);\n\n        owner.transfer(address(this).balance);\n    }\n}\n"
    },
    "contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ncontract Ownable {\n  address payable public owner;\n\n  constructor(address initialOwner) {\n    owner = payable(initialOwner);\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  event LogNewOwner(address sender, address newOwner);\n\n  function setOwner(address payable newOwner) external onlyOwner {\n    require(newOwner != address(0));\n    owner = newOwner;\n    emit LogNewOwner(msg.sender, newOwner);\n  }\n}\n"
    },
    "contracts/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport './IHasUpstream.sol';\nimport './FreeMarketBase.sol';\nimport './EternalStorage.sol';\n\n\ncontract Proxy is FreeMarketBase, IHasUpstream {\n  bytes32 constant runnerAddresses = 0x32b7d36eef9191cec628a9b46ddda74b702cf693ad48a065f3f9e5fcc4ea08f5; // keccak256('runnerAddresses')\n\n  constructor(\n    address owner,\n    address storageAddress,\n    address upstream,\n    bool userProxy\n  ) FreeMarketBase(owner, storageAddress, upstream, userProxy) {}\n\n  function getUpstream() external view virtual returns (address) {\n    return upstreamAddress;\n  }\n\n  function resolveUpstream() internal view returns (address addr) {\n    address upstreamFromArgs = getAddressFromCalldata();\n\n    if (upstreamFromArgs != address(0)) {\n\n      EternalStorage eternalStorage = EternalStorage(eternalStorageAddress);\n      require(eternalStorage.containsEnumerableMapAddressToUint(runnerAddresses, upstreamFromArgs), 'provided upstream not whitelisted');\n      return upstreamFromArgs;\n    } else {\n\n    }\n    return upstreamAddress;\n  }\n\n  function getAddressFromCalldata() internal pure returns (address addr) {\n    assembly {\n      let offset := add(4, calldataload(4))\n      addr := calldataload(offset)\n    }\n  }\n\n  /// @dev this forwards all calls generically to upstream, only the owner can invoke this\n  fallback() external payable {\n\n    address upstream = resolveUpstream();\n\n    _delegate(upstream);\n  }\n\n  /// @dev this allows this contract to receive ETH\n  receive() external payable {\n    // noop\n  }\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   */\n  function _delegate(address upstr) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), upstr, 0, calldatasize(), 0, 0)\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n      // let ptr := mload(0x40)\n      // calldatacopy(ptr, 0, calldatasize())\n      // let result := delegatecall(gas(), implementation, ptr, calldatasize(), 0, 0)\n      // let size := returndatasize()\n      // returndatacopy(ptr, 0, size)\n      // switch result\n      // case 0 {\n      //   revert(ptr, size)\n      // }\n      // default {\n      //   return(ptr, size)\n      // }\n    }\n  }\n}\n"
    },
    "contracts/StepInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nstruct StepInfo {\n  uint16 stepTypeId;\n  bool feeIsPercent;\n  uint256 fee;\n  address latest;\n  address[] whitelist;\n  address[] blacklist;\n}\n"
    },
    "contracts/WorkflowRunner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\nimport '@freemarket/core/contracts/model/Workflow.sol';\nimport '@freemarket/core/contracts/IWorkflowStep.sol';\nimport '@freemarket/core/contracts/IWorkflowStepBeforeAll.sol';\nimport '@freemarket/core/contracts/IWorkflowStepAfterAll.sol';\nimport '@freemarket/core/contracts/LibPercent.sol';\nimport '@freemarket/core/contracts/IWorkflowRunner.sol';\nimport './FrontDoor.sol';\nimport './LibAssetBalances.sol';\nimport './ChainBranch.sol';\nimport './AssetComparisons.sol';\nimport './LibConfigReader.sol';\n\n\nuint16 constant STEP_TYPE_ID_CHAIN_BRANCH = 1;\nuint16 constant STEP_TYPE_ID_ASSET_AMOUNT_BRANCH = 2;\nuint16 constant STEP_TYPE_ID_PREV_OUTPUT_BRANCH = 3;\n\ncontract WorkflowRunner is FreeMarketBase, ReentrancyGuard, IWorkflowRunner {\n  constructor(\n    address payable frontDoorAddress\n  )\n    FreeMarketBase(\n      msg.sender, // owner\n      FrontDoor(frontDoorAddress).eternalStorageAddress(), // eternal storage address\n      address(0), // upstream (this doesn't have one)\n      false // isUserProxy\n    )\n  {}\n\n  /// @notice This event is emitted when a workflow execution begins.\n  /// @param userAddress The user for which this workflow is executing.\n  /// @param workflow The workflow.\n  event WorkflowExecution(address userAddress, Workflow workflow);\n\n  /// @notice This event is emitted when immediately after invoking a step in the workflow.\n  /// @param stepIndex The index of the step in the Workflow.steps array.\n  /// @param step The step configuration.\n  /// @param stepTypeId The logical id of the step (also repeated in the step param but duplicated here for convenience).\n  /// @param stepAddress The address of the step used for this invocation.\n  /// @param inputAssetAmounts The input assets, with the absolute amount of each asset.\n  /// @param result The result returned form the step invocation.\n  event WorkflowStepExecution(\n    uint16 stepIndex,\n    WorkflowStep step,\n    uint16 stepTypeId,\n    address stepAddress,\n    AssetAmount[] inputAssetAmounts,\n    WorkflowStepResult result,\n    uint256[] feesTaken\n  );\n\n  /// @notice This event is emitted after the workflow has completed, once for each asset ramining with a non-zero amount.\n  /// @param asset The asset.\n  /// @param totalAmount The total amount of the asset.\n  /// @param feeAmount The portion of the total amount that FMP will keep as a fee.\n  /// @param userAmount The portion of the total amount that is sent to the user.\n  event RemainingAsset(Asset asset, uint256 totalAmount, uint256 feeAmount, uint256 userAmount);\n\n  /// @notice This event is emitted when this is a continuation of a workflow from another chain\n  /// @param nonce The nonce provided by the caller on the source chain, used to correlate the source chain workflow segment with this segment.\n  /// @param startingAssets The asset that was transferred from the source chain to this chain\n  event WorkflowContinuation(uint256 nonce, address userAddress, AssetAmount[] startingAssets);\n\n  using LibAssetBalances for LibAssetBalances.AssetBalances;\n\n  function getStepAddress(uint16 stepTypeId) external view returns (address) {\n    return LibConfigReader.getStepAddressInternal(eternalStorageAddress, stepTypeId);\n  }\n\n  function executeWorkflow(Workflow calldata workflow) external payable nonReentrant {\n    AssetAmount[] memory startingAssets = new AssetAmount[](1);\n    startingAssets[0] = AssetAmount(Asset(AssetType.Native, address(0)), 0);\n    executeWorkflow(msg.sender, workflow, startingAssets);\n  }\n\n  function executeWorkflow(address userAddress, Workflow memory workflow, AssetAmount[] memory startingAssets) internal {\n    emit WorkflowExecution(userAddress, workflow);\n    // workflow starts on the step with index 0\n    uint16 currentStepIndex = 0;\n    // keep track of asset balances\n    LibAssetBalances.AssetBalances memory assetBalances;\n    // credit ETH if sent with this call\n    if (msg.value != 0) {\n      // TODO add event\n      assetBalances.credit(0, msg.value);\n    }\n\n    // credit any starting assets (if this is a continutation workflow with assets sent by a bridge)\n    for (uint256 i = 0; i < startingAssets.length; i++) {\n      AssetAmount memory startingAsset = startingAssets[i];\n      if (startingAsset.amount > 0) {\n        assetBalances.credit(startingAsset.asset, startingAsset.amount);\n      }\n    }\n\n    executeBeforeAlls(workflow, userAddress);\n\n    bool isSubscriber = LibConfigReader.isSubscriber(eternalStorageAddress, msg.sender);\n    bool feeAlreadyTaken = isSubscriber;\n\n    // execute steps\n    if (workflow.steps.length > 0) {\n      while (true) {\n        // prepare to invoke the step\n        WorkflowStep memory currentStep = workflow.steps[currentStepIndex];\n\n        // handle core branch step types here\n        if (currentStep.stepTypeId >= STEP_TYPE_ID_CHAIN_BRANCH && currentStep.stepTypeId <= STEP_TYPE_ID_PREV_OUTPUT_BRANCH) {\n          int16 nextStepIndex;\n          if (currentStep.stepTypeId == STEP_TYPE_ID_CHAIN_BRANCH) {\n            nextStepIndex = ChainBranch.getNextStepIndex(currentStep);\n          } else if (currentStep.stepTypeId == STEP_TYPE_ID_ASSET_AMOUNT_BRANCH) {\n            nextStepIndex = AssetComparison.getNextStepIndex(currentStep, assetBalances, AssetComparisonType.Balance);\n          } else {\n            // step type must be STEP_TYPE_ID_PREV_OUTPUT_BRANCH\n            nextStepIndex = AssetComparison.getNextStepIndex(currentStep, assetBalances, AssetComparisonType.Credit);\n          }\n          if (nextStepIndex == -1) {\n            break;\n          }\n          currentStepIndex = uint16(nextStepIndex);\n          continue;\n        }\n\n        address stepAddress = resolveStepAddress(currentStep.stepAddress, currentStep.stepTypeId);\n        AssetAmount[] memory inputAssetAmounts = resolveAmounts(userAddress, assetBalances, currentStep.inputAssets);\n\n        // invoke the step\n        WorkflowStepResult memory stepResult = invokeStep(stepAddress, inputAssetAmounts, currentStep.argData, userAddress);\n\n        // debit input assets\n        for (uint256 i = 0; i < stepResult.inputAssetAmounts.length; ++i) {\n          assetBalances.debit(stepResult.inputAssetAmounts[i].asset, stepResult.inputAssetAmounts[i].amount);\n        }\n\n        // determine if fee is relative or absolute, and fee amount\n        bool feeIsPercent;\n        uint256 stepFee = 0;\n        if (stepResult.fee != -1) {\n          // fee is in decibips\n          stepFee = uint24(stepResult.fee);\n          // just treat it as an absolute 0 if it's 0% to avoid extra computation later\n          feeIsPercent = stepFee > 0;\n        } else {\n          // fee is absolute\n          (stepFee, feeIsPercent) = LibConfigReader.getStepFee(eternalStorageAddress, currentStep.stepTypeId);\n        }\n\n        uint256[] memory feesTaken = new uint256[](stepResult.outputAssetAmounts.length);\n        // credit output assets\n        for (uint256 i = 0; i < stepResult.outputAssetAmounts.length; ++i) {\n          // calculate exact fee\n          uint256 feeAmount;\n          if (isSubscriber) {\n            feeAmount = 0;\n          } else if (feeIsPercent) {\n            feeAmount = LibPercent.percentageOf(stepResult.outputAssetAmounts[i].amount, stepFee);\n          } else {\n            feeAmount = stepFee;\n          }\n          feeAlreadyTaken = feeAlreadyTaken || feeAmount > 0;\n          uint256 callerAmount = stepResult.outputAssetAmounts[i].amount - feeAmount;\n          assetBalances.credit(stepResult.outputAssetAmounts[i].asset, callerAmount);\n          feesTaken[i] = feeAmount;\n        }\n\n        emit WorkflowStepExecution(\n          currentStepIndex,\n          currentStep,\n          currentStep.stepTypeId,\n          stepAddress,\n          inputAssetAmounts,\n          stepResult,\n          feesTaken\n        );\n\n        if (currentStep.nextStepIndex == -1) {\n          break;\n        }\n        currentStepIndex = uint16(currentStep.nextStepIndex);\n      }\n    }\n\n    executeAfterAlls(workflow, userAddress);\n\n    refundUser(userAddress, assetBalances, feeAlreadyTaken);\n  }\n\n  function executeBeforeAlls(Workflow memory workflow, address userAddress) internal {\n    for (uint256 i = 0; i < workflow.beforeAll.length; ++i) {\n      executeBeforeAfter(IWorkflowStepBeforeAll.beforeAll.selector, workflow.beforeAll[i], userAddress);\n    }\n  }\n\n  function executeAfterAlls(Workflow memory workflow, address userAddress) internal {\n    for (uint256 i = 0; i < workflow.afterAll.length; ++i) {\n      executeBeforeAfter(IWorkflowStepAfterAll.afterAll.selector, workflow.afterAll[i], userAddress);\n    }\n  }\n\n  function executeBeforeAfter(bytes4 selector, BeforeAfter memory beforeAfter, address userAddress) internal {\n    address stepAddress = resolveStepAddress(beforeAfter.stepAddress, beforeAfter.stepTypeId);\n    (bool success, bytes memory returnData) = stepAddress.delegatecall(abi.encodeWithSelector(selector, beforeAfter.argData, userAddress));\n    require(success, string(returnData));\n  }\n\n  function refundUser(address userAddress, LibAssetBalances.AssetBalances memory assetBalances, bool feeAlreadyTaken) internal {\n    uint256 fee;\n    bool feeIsPercent;\n\n    if (feeAlreadyTaken) {\n      // fees taken during one or more steps\n      fee = 0;\n      feeIsPercent = false;\n    } else {\n      (fee, feeIsPercent) = LibConfigReader.getDefaultFee(eternalStorageAddress);\n      // treat 0% as absolute 0\n      feeIsPercent = feeIsPercent && fee > 0;\n    }\n\n\n    for (uint8 i = 0; i < assetBalances.getAssetCount(); ++i) {\n\n      AssetAmount memory ab = assetBalances.getAssetAt(i);\n      Asset memory asset = ab.asset;\n      uint256 feeAmount;\n      if (feeIsPercent) {\n        feeAmount = LibPercent.percentageOf(ab.amount, fee);\n\n      } else {\n        feeAmount = fee;\n\n      }\n      uint256 userAmount = ab.amount < feeAmount ? ab.amount : ab.amount - feeAmount;\n      emit RemainingAsset(asset, ab.amount, feeAmount, userAmount);\n      if (asset.assetType == AssetType.Native) {\n        require(address(this).balance >= ab.amount, 'computed native > actual');\n        payable(userAddress).transfer(userAmount);\n      } else if (asset.assetType == AssetType.ERC20) {\n        IERC20 token = IERC20(asset.assetAddress);\n        SafeERC20.safeTransfer(token, userAddress, userAmount);\n      } else {\n        revert('unknown asset type in assetBalances');\n      }\n    }\n  }\n\n  function invokeStep(\n    address stepAddress,\n    AssetAmount[] memory inputAssetAmounts,\n    bytes memory data,\n    address userAddress\n  ) internal returns (WorkflowStepResult memory) {\n    (bool success, bytes memory returnData) = stepAddress.delegatecall(\n      abi.encodeWithSelector(IWorkflowStep.execute.selector, inputAssetAmounts, data, userAddress)\n    );\n    require(success, string(returnData));\n    return abi.decode(returnData, (WorkflowStepResult));\n  }\n\n  function resolveStepAddress(address frozenStepAddress, uint16 stepTypeId) internal view returns (address) {\n    // address zero indicates that the step implementation is not frozen\n    if (frozenStepAddress == address(0)) {\n      return LibConfigReader.getStepAddressInternal(eternalStorageAddress, stepTypeId);\n    }\n    // ensure given address is in the whitelist for given stepTypeId\n    bool isWhitelisted = LibConfigReader.isStepAddressWhitelisted(eternalStorageAddress, stepTypeId, frozenStepAddress);\n    require(isWhitelisted, 'step not white listed');\n    return frozenStepAddress;\n  }\n\n  function resolveAmounts(\n    address userAddress,\n    LibAssetBalances.AssetBalances memory assetBalances,\n    WorkflowStepInputAsset[] memory inputAssets\n  ) internal returns (AssetAmount[] memory) {\n    AssetAmount[] memory rv = new AssetAmount[](inputAssets.length);\n    for (uint256 i = 0; i < inputAssets.length; ++i) {\n      WorkflowStepInputAsset memory stepInputAsset = inputAssets[i];\n      rv[i].asset = stepInputAsset.asset;\n      if (stepInputAsset.sourceIsCaller) {\n        transferFromCaller(userAddress, stepInputAsset, assetBalances);\n      }\n      uint256 currentWorkflowAssetBalance = assetBalances.getAssetBalance(stepInputAsset.asset);\n      if (stepInputAsset.amountIsPercent) {\n        rv[i].amount = LibPercent.percentageOf(currentWorkflowAssetBalance, stepInputAsset.amount);\n        // rv[i].amount = 1;\n      } else {\n        require(currentWorkflowAssetBalance >= stepInputAsset.amount, 'absolute amt > wf balance');\n        rv[i].amount = stepInputAsset.amount;\n      }\n    }\n    return rv;\n  }\n\n  function transferFromCaller(\n    address userAddress,\n    WorkflowStepInputAsset memory inputAssetAmount,\n    LibAssetBalances.AssetBalances memory assetBalances\n  ) internal {\n    require(inputAssetAmount.amountIsPercent == false, 'rel not supported');\n    if (inputAssetAmount.asset.assetType == AssetType.Native) {\n      // it's not possible to 'trasfer from caller' for native assets\n      // assetBalances should have been initialized with the correct amount\n    } else if (inputAssetAmount.asset.assetType == AssetType.ERC20) {\n      IERC20 token = IERC20(inputAssetAmount.asset.assetAddress);\n      uint256 allowance = token.allowance(userAddress, address(this));\n      require(allowance >= inputAssetAmount.amount, 'insuf allow for erc20');\n      SafeERC20.safeTransferFrom(token, userAddress, address(this), inputAssetAmount.amount);\n      assetBalances.credit(inputAssetAmount.asset, inputAssetAmount.amount);\n    } else {\n      revert('unk asset type in inputAssetAmounts');\n    }\n  }\n\n  function continueWorkflow(\n    address userAddress,\n    uint256 nonce,\n    Workflow memory workflow,\n    AssetAmount[] memory startingAssets\n  ) external payable {\n    // only step contracts are allowed to call this\n    require(LibConfigReader.isStepAddressWhitelisted(eternalStorageAddress, msg.sender), 'caller not valid');\n    emit WorkflowContinuation(nonce, userAddress, startingAssets);\n    for (uint256 i = 0; i < startingAssets.length; ++i) {\n      if (startingAssets[i].asset.assetType == AssetType.Native) {\n        // the calling step should have sent the correct amount of native\n        require(msg.value >= startingAssets[i].amount, 'msg.value < starting asset amount');\n      } else if (startingAssets[i].asset.assetType == AssetType.ERC20) {\n        // the calling step should have approved the correct amount of the erc20\n        IERC20 token = IERC20(startingAssets[i].asset.assetAddress);\n        uint256 allowance = token.allowance(msg.sender, address(this));\n        require(allowance >= startingAssets[i].amount, 'insuf. allow for erc20');\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), startingAssets[i].amount);\n      } else {\n        revert('unk asset type in startingAssets');\n      }\n    }\n    executeWorkflow(userAddress, workflow, startingAssets);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}